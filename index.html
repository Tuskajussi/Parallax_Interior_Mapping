<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interior Parallax Mapping with Three.js</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.6.9/umd/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/EXRLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-family: sans-serif;
            font-size: 13px;
            z-index: 100;
            min-width: 220px;
        }
        #controls h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }
        #controls label {
            display: block;
            margin: 8px 0 3px 0;
        }
        #controls input[type="range"] {
            width: 100%;
        }
        #controls .value {
            float: right;
            color: #8cf;
        }
        #controls .group {
            margin-top: 12px;
            padding-top: 8px;
            border-top: 1px solid #444;
        }
        #canvasContainer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 800px;
            height: 600px;
            min-width: 200px;
            min-height: 150px;
            resize: both;
            overflow: hidden;
            border: 2px solid #444;
            border-radius: 8px;
            background: #222;
        }
        #canvasContainer canvas {
            width: 100% !important;
            height: 100% !important;
            display: block;
        }
    </style>
</head>
<body style="margin: 0; overflow: hidden; background: #111;">
    <div id="canvasContainer">
        <canvas id="glCanvas"></canvas>
    </div>
    <div id="controls">
        <h3>Interior Parallax Controls</h3>
        
        <label>Depth Scale <span class="value" id="depthScaleVal">1.0</span></label>
        <input type="range" id="depthScale" min="0" max="3" step="0.05" value="1.0">
        
        <div class="group">
            <label>Flip X <span class="value" id="flipXVal">-1</span></label>
            <input type="range" id="flipX" min="-1" max="1" step="0.1" value="-1">
            
            <label>Flip Y <span class="value" id="flipYVal">1</span></label>
            <input type="range" id="flipY" min="-1" max="1" step="0.1" value="1">
            
            <label>Flip Z <span class="value" id="flipZVal">1</span></label>
            <input type="range" id="flipZ" min="-1" max="1" step="0.1" value="1">
        </div>
        
        <div class="group">
            <label>Rotation X° <span class="value" id="rotXVal">180</span></label>
            <input type="range" id="rotX" min="-180" max="180" step="1" value="180">
            
            <label>Rotation Y° <span class="value" id="rotYVal">0</span></label>
            <input type="range" id="rotY" min="-180" max="180" step="1" value="0">
            
            <label>Rotation Z° <span class="value" id="rotZVal">-180</span></label>
            <input type="range" id="rotZ" min="-180" max="180" step="1" value="-180">
        </div>
        
        <div class="group">
            <label>Upload Texture <span class="value" id="uploadedName">roomtest5.exr</span></label>
            <input type="file" id="fileInput" accept=".exr,.jpg,.jpeg,.png,image/*">
            <img id="preview" alt="texture preview" style="display:block;width:200px;margin-top:8px;border-radius:4px;border:1px solid #333;background:#000;cursor:zoom-in" />
            <div style="margin-top:6px;display:flex;gap:6px;">
                <button id="savePreviewBtn" style="flex:1">Save Preview</button>
                <button id="clearPreviewBtn" style="flex:1">Clear Saved</button>
            </div>
        </div>
    </div>

    <script>
        const container = document.getElementById('canvasContainer');
        const canvas = document.getElementById('glCanvas');
        
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        let material = null;
        let plane = null;

        const loader = new THREE.EXRLoader();
        loader.load('roomtest5.exr', function(texture) {
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;

            const geometry = new THREE.PlaneGeometry(10, 10, 1, 1);

            // Load external GLSL shaders
            const fileLoader = new THREE.FileLoader();
            fileLoader.setResponseType('text');

            fileLoader.load('shaders/pom.vert.glsl', function(vertexShader) {
                fileLoader.load('shaders/pom.frag.glsl', function(fragmentShader) {
                    material = new THREE.ShaderMaterial({
                        uniforms: {
                            map: { value: texture },
                            depthScale: { value: 1.0 },
                            flipVector: { value: new THREE.Vector3(-1, 1, 1) },
                            rotationDeg: { value: new THREE.Vector3(180, 0, -180) }
                        },
                        vertexShader: vertexShader,
                        fragmentShader: fragmentShader
                    });

                    plane = new THREE.Mesh(geometry, material);
                    plane.rotation.y = Math.PI / 6; // 30 degrees
                    scene.add(plane);

                    camera.position.z = 5;

                    // Wire up UI controls
                    setupControls();

                    function animate() {
                        requestAnimationFrame(animate);
                        controls.update();
                        renderer.render(scene, camera);
                    }
                    animate();
                });
            });
        });

        function setupControls() {
            // Depth Scale
            document.getElementById('depthScale').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                material.uniforms.depthScale.value = val;
                document.getElementById('depthScaleVal').textContent = val.toFixed(2);
            });

            // Flip Vector
            document.getElementById('flipX').addEventListener('input', (e) => {
                material.uniforms.flipVector.value.x = parseFloat(e.target.value);
                document.getElementById('flipXVal').textContent = e.target.value;
            });
            document.getElementById('flipY').addEventListener('input', (e) => {
                material.uniforms.flipVector.value.y = parseFloat(e.target.value);
                document.getElementById('flipYVal').textContent = e.target.value;
            });
            document.getElementById('flipZ').addEventListener('input', (e) => {
                material.uniforms.flipVector.value.z = parseFloat(e.target.value);
                document.getElementById('flipZVal').textContent = e.target.value;
            });

            // Rotation
            document.getElementById('rotX').addEventListener('input', (e) => {
                material.uniforms.rotationDeg.value.x = parseFloat(e.target.value);
                document.getElementById('rotXVal').textContent = e.target.value;
            });
            document.getElementById('rotY').addEventListener('input', (e) => {
                material.uniforms.rotationDeg.value.y = parseFloat(e.target.value);
                document.getElementById('rotYVal').textContent = e.target.value;
            });
            document.getElementById('rotZ').addEventListener('input', (e) => {
                material.uniforms.rotationDeg.value.z = parseFloat(e.target.value);
                document.getElementById('rotZVal').textContent = e.target.value;
            });

            // File upload -> replace material texture (roomtest5.exr remains default)
            const fileInput = document.getElementById('fileInput');
            if (fileInput) {
                fileInput.addEventListener('change', (ev) => {
                    const file = ev.target.files && ev.target.files[0];
                    if (!file) return;
                    const url = URL.createObjectURL(file);
                    const nameEl = document.getElementById('uploadedName');
                    const ext = file.name.split('.').pop().toLowerCase();
                        // remember uploaded file for preview decisions
                        window._lastUploadedURL = url;
                        window._lastUploadedExt = ext;

                    function applyTexture(tex, isSRGB) {
                        tex.wrapS = THREE.RepeatWrapping;
                        tex.wrapT = THREE.RepeatWrapping;
                        tex.encoding = isSRGB ? THREE.sRGBEncoding : THREE.LinearEncoding;
                        tex.needsUpdate = true;
                        material.uniforms.map.value = tex;
                        nameEl.textContent = file.name;
                        // update preview from renderer snapshot
                        try { updatePreview(); } catch (e) { /* ignore */ }
                    }

                    if (ext === 'exr') {
                        const exrLoader = new THREE.EXRLoader();
                        exrLoader.load(url, (tex) => {
                            applyTexture(tex, false);
                            URL.revokeObjectURL(url);
                            // generate preview from texture (EXR)
                            generatePreviewFromTexture(tex);
                        }, undefined, (err) => {
                            console.error('EXR load error', err);
                            URL.revokeObjectURL(url);
                        });
                    } else {
                        const texLoader = new THREE.TextureLoader();
                        texLoader.load(url, (tex) => {
                            applyTexture(tex, true);
                            // for normal images we can simply point preview to the object URL
                            const preview = document.getElementById('preview');
                            if (preview) preview.src = url;
                            // revoke URL after a short delay to allow browser to use it
                            setTimeout(() => URL.revokeObjectURL(url), 30000);
                        }, undefined, (err) => {
                            console.error('Texture load error', err);
                            URL.revokeObjectURL(url);
                        });
                    }
                });
            }
        }

        // Resize handling with ResizeObserver for container
        const resizeObserver = new ResizeObserver(entries => {
            for (let entry of entries) {
                const width = entry.contentRect.width;
                const height = entry.contentRect.height;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            }
        });
        resizeObserver.observe(container);

        // Preview update helper: snapshot the renderer and set preview image
        function updatePreview() {
            const preview = document.getElementById('preview');
            if (!preview) return;
            try {
                // If user uploaded a normal image file, we already set preview.src to the object URL.
                // For EXR (or when no file URL available) generate preview from the texture using a small render target.
                const ext = window._lastUploadedExt || '';
                if (ext && ext !== 'exr') {
                    // nothing to do; preview already set to file URL
                    return;
                }
                // fallback: if material map exists, render it to small RT and read pixels
                if (material && material.uniforms && material.uniforms.map && material.uniforms.map.value) {
                    generatePreviewFromTexture(material.uniforms.map.value);
                }
            } catch (e) {
                console.warn('Preview update failed', e);
            }
        }

        // Initial preview once scene is ready (call after material is created)
        setTimeout(() => { try { updatePreview(); } catch(e){} }, 500);

        // Save preview to localStorage (if small enough)
        function savePreviewToStorage(dataURL) {
            if (!dataURL) return;
            try {
                // limit ~200KB to avoid exceeding storage
                if (dataURL.length > 200000) {
                    console.warn('Preview too large to save (~' + Math.round(dataURL.length/1024) + 'KB)');
                    return;
                }
                localStorage.setItem('pom_preview', dataURL);
                console.log('Preview saved to localStorage');
            } catch (e) {
                console.warn('Saving preview failed', e);
            }
        }

        function loadPreviewFromStorage() {
            try {
                const data = localStorage.getItem('pom_preview');
                if (data) {
                    const preview = document.getElementById('preview');
                    if (preview) preview.src = data;
                    const nameEl = document.getElementById('uploadedName');
                    if (nameEl) nameEl.textContent = 'saved_preview';
                }
            } catch (e) { /* ignore */ }
        }

        function clearSavedPreview() {
            localStorage.removeItem('pom_preview');
            const preview = document.getElementById('preview');
            if (preview) preview.src = '';
            const nameEl = document.getElementById('uploadedName');
            if (nameEl) nameEl.textContent = 'roomtest5.exr';
        }

        // click-to-zoom handlers
        const previewImg = document.getElementById('preview');
        if (previewImg) {
            previewImg.addEventListener('click', () => {
                const src = previewImg.src;
                if (!src) return;
                const modal = document.getElementById('previewModal');
                const large = document.getElementById('previewLarge');
                if (large && modal) {
                    large.src = src;
                    modal.style.display = 'flex';
                }
            });
        }
        const closeBtn = document.getElementById('closePreview');
        if (closeBtn) closeBtn.addEventListener('click', () => { document.getElementById('previewModal').style.display = 'none'; });

        const saveBtn = document.getElementById('savePreviewBtn');
        if (saveBtn) saveBtn.addEventListener('click', () => {
            const preview = document.getElementById('preview');
            if (!preview || !preview.src) return;
            // if preview is object URL, capture it via image draw
            if (window._lastUploadedExt && window._lastUploadedExt !== 'exr') {
                // try to fetch and convert to dataURL
                captureImageToDataURL(preview.src, (dataURL) => { if (dataURL) savePreviewToStorage(dataURL); });
            } else {
                savePreviewToStorage(preview.src);
            }
        });

        const clearBtn = document.getElementById('clearPreviewBtn');
        if (clearBtn) clearBtn.addEventListener('click', () => { clearSavedPreview(); });

        // Helper: capture image URL into dataURL via canvas
        function captureImageToDataURL(src, cb) {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
                const cw = 512; const ch = Math.max(128, Math.floor(cw * img.height / img.width));
                const c = document.createElement('canvas'); c.width = cw; c.height = ch;
                const ctx = c.getContext('2d');
                // center-cover
                const aspect = img.width / img.height;
                const destAspect = cw / ch;
                let dw = cw, dh = ch, dx = 0, dy = 0;
                if (aspect > destAspect) {
                    // image wider
                    const scale = ch / img.height; dw = img.width * scale; dx = - (dw - cw) / 2;
                } else {
                    const scale = cw / img.width; dh = img.height * scale; dy = - (dh - ch) / 2;
                }
                ctx.drawImage(img, dx, dy, dw, dh);
                try { cb(c.toDataURL('image/png')); } catch (e) { cb(null); }
            };
            img.onerror = () => cb(null);
            img.src = src;
        }

        // load saved preview if exists
        loadPreviewFromStorage();

        // Generate a preview image from a Three.Texture (works for EXR data textures)
        function generatePreviewFromTexture(tex) {
            const preview = document.getElementById('preview');
            if (!preview || !tex) return;
            const w = 512;
            const h = Math.max(128, Math.floor(w * 0.5));

            const rt = new THREE.WebGLRenderTarget(w, h, { type: THREE.UnsignedByteType });
            const prevScene = new THREE.Scene();
            const materialPreview = new THREE.MeshBasicMaterial({ map: tex });
            const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), materialPreview);
            prevScene.add(quad);
            const ortho = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

            const oldRenderTarget = renderer.getRenderTarget();
            renderer.setRenderTarget(rt);
            renderer.clear();
            renderer.render(prevScene, ortho);

            const buffer = new Uint8Array(w * h * 4);
            try {
                renderer.readRenderTargetPixels(rt, 0, 0, w, h, buffer);
            } catch (e) {
                console.warn('readRenderTargetPixels failed', e);
                renderer.setRenderTarget(oldRenderTarget);
                rt.dispose();
                materialPreview.dispose();
                quad.geometry.dispose();
                return;
            }

            renderer.setRenderTarget(oldRenderTarget);

            // create canvas and put pixels (flip Y)
            const canvas = document.createElement('canvas');
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(w, h);
            // flip rows while copying
            for (let y = 0; y < h; y++) {
                const srcRow = (h - 1 - y) * w * 4;
                const dstRow = y * w * 4;
                for (let i = 0; i < w * 4; i++) {
                    imageData.data[dstRow + i] = buffer[srcRow + i];
                }
            }
            ctx.putImageData(imageData, 0, 0);
            preview.src = canvas.toDataURL('image/png');

            // cleanup
            rt.dispose();
            materialPreview.dispose();
            quad.geometry.dispose();
        }
    </script>
    <!-- Modal for zoomed preview -->
    <div id="previewModal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.85);align-items:center;justify-content:center;z-index:10000">
        <div style="position:relative;max-width:90vw;max-height:90vh;">
            <button id="closePreview" style="position:absolute;right:-16px;top:-16px;background:#fff;border-radius:50%;width:32px;height:32px;border:0;cursor:pointer">×</button>
            <img id="previewLarge" src="" style="display:block;max-width:90vw;max-height:90vh;border-radius:6px;" />
        </div>
    </div>
    <script>
        (function(){
            const modal = document.getElementById('previewModal');
            const closeBtn = document.getElementById('closePreview');
            const previewLarge = document.getElementById('previewLarge');
            if (closeBtn && modal) closeBtn.addEventListener('click', () => { modal.style.display = 'none'; });
            // clicking backdrop (outside the image) closes modal
            if (modal) modal.addEventListener('click', (e) => { if (e.target === modal) modal.style.display = 'none'; });
            // Escape key closes modal
            document.addEventListener('keydown', (e) => { if ((e.key === 'Escape' || e.key === 'Esc') && modal && modal.style.display !== 'none') modal.style.display = 'none'; });
            // clicking the large image also closes (convenience)
            if (previewLarge) previewLarge.addEventListener('click', () => { if (modal) modal.style.display = 'none'; });
        })();
    </script>
</body>
</html>